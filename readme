psh is an experimental, non-posix system/login shell which extends prolog with
a custom toplevel and functionality to facilitate interoperating with a posix
system.

Presently psh is incomplete and has no releases or stable interfaces. Existing
code may be thrown out or rewritten without warning.

Note that built psh binaries may be affected by GNU Prolog's licensing terms (GPL/LGPL).

Currently psh has major limitations including:
	Lacks pipeline constructors for composing external processes
	Lacks high level fd redirection routines
	Limited job control (background processes not tracked)
	Sparse documentation
	Prolog predicates in the same process can't be interrupted
	Lacks a general way to trap signals
	dubious line editing (see below)

Some of these limitations require extending Gprolog as the builtin os interface has some omissions. Other
prolog implementations may not require extension (e.g., swi-prolog exposes a predicate for registering signal handlers),
but fail to meet other requirements (such as supporting native code compilation).

Currently, line editing support is a bit underwhelming. GProlog does provide its own 'linedit' mechanism which
allows expanding prolog atoms. It doesn't, however, support extension or vi-like keybindings. If vi-like keybindings
are needed, install rlwrap, set LINEDIT='no', set PSH_RLWRAP, and set the vi editing mode in ~/.inputrc (see readline(3));
doing so will cause psh to run itself under rlwrap automatically. I hope to eventually implement at least basic line editing
functionality, supporting at least a subset of vi keybindings, line history, and basic file-path-aware tab completion.

Despite its myriad limitations, I do use psh as my login shell.

psh can be built by running `make` (any posix make should work). gplc - the gprolog compiler - and
gcc are build dependencies (other C compilers may work, but gplc appears to output errors when clang
is used). Some psh commands assume other runtime dependencies (e.g., less/1 assumes less is installed),
but these predicates can fail without affecting the functioning of the larger system.

The build process will first build make.pl, which will then expand psh specific constructs in the psh
source. The expanded prolog files are named build/*.pl and subsequently compiled with gplc (which will
call CC to compile os.c). The syntax of the psh source code requires make.pl to expand them. Currently,
code loaded into psh must be valid prolog and thus cannot use these constructs.

Psh itself also implements operators using op/3, which can be used in code loaded into psh (e.g., via
consult, [user], etc.). The op/3 directives are in op.pl so that they can be included separately.

The predicate help/0 will output a (small) subset of implemented predicates. Psh predicates intended for
use at the psh top level are highly modal. In particular, if a predicate p/(n+1) has an 'output' variable,
it is generally the last variable, and p/n will generally output to the terminal.

There are two primary composition operators: (<>)/2 and (<--)/2. The expression (p <> q) is equivalent to
(p(X), q(X,Y), puts(Y)), with the additional property that if Y is a list puts is lifted over it. The expression
(p <-- q) is equivalent to (call(q,X), call(p,X)). These expressions can be chained (e.g., (s <-- p <> q <> r)).

Due to the way these are implemented, routines which require variables to be instantiated early may throw errors
when using (<>). This can be corrected by using (<--) instead. These operators are likely to be replaced. Their
use can be made more convenient with the combinatorial predicates (dup, rot, swap, etc) which resemble their forth
counterparts.

Currently, psh will resolve predicates to atoms in some cases. This faulty enables inputing structural path expressions
(non-atomic) path expressions. Due to the current mechanism, any functor f/n with an associated predicate f/n+1 where n>0
can be used in path expressions, but this is liable to change. The principal constructors are:
	(//X)		relative path -> root-prefixed absolute path
	(~/X)		relative path -> user-home-prefixed absolute path
	(X/Y)		path -> file component -> path
	(X dot Y)	atom -> atom -> atom (joined by a '.' character)
	(X ++ Y)	atom -> atom -> atom (concatenation)

The underlying predicate that accomplishes this is atom_resolve/2. In psh source files, the following expansion occurs:
	p(Q), [R] => q(Q,T), r(T,R).
		expands to:
	p(Q,R) :- atom_resolve(Q,Q0), q(Q0,T), r(T,R).
That is to say that occurrences of (=>) in the psh source indicate expressions which take path expressions as input (the
list following the predicate in the head of the clause, mirroring DCG semi-context notation, indicates a list of variables
of the head functor which should not be affected by the aforementioned transformation).

--

Many routines, such as cd/pwd/ed/file are set as unary operators and need to
be surrounded in parenthesis for them to be used as atoms. Some notable routines include:

ed filename.       % edit filename in EDITOR (default: vi)
ied(data,O)        % edit data as list of prolog clauses in EDITOR then read/2 into O.
fl.                % list files ending in .pl
fl +f/n.           % display code from the source file for functor f with arity n
fl filename.       % show the source of filename.pl using portray_clause
edit filename.     % edit filename.pl in EDITOR
edit +f/n.         % edit the source file for functor f with arity n in EDITOR
                   %    ( for editors other than vi, add config(editor_line_flag,FLAG) to pshrc to support jumping to the
                   %      the line number a predicate is defined on).
cd dir.            % change directory to dir
pwd.               % working directory
ls.                % list files not starting with '.'
less(list).        % display list of codes in `less`
find(p).           % find files 1 level deep satisfying predicate p/1
find(p,depth).     % find files upto depth satisfying predicate p/1
find(p,depth,dir). % find files upto depth satisfying predicate p/1 in dir
filter(p,dom,sat). % sat is a list containing solutions of p constrained to domain dom
endswith(str,x).   % x ends with str
startswith(str,x). % x starts with str
limit(list).       % output first 10 items in list
limit(c,list).     % output first c items in list (or last c items if negative).
pred via filename. % display the source for predicate pred as defined in filename
where p/n.         % display the path to the file that defines predicate p with arity n
cat filename.      % this is badly named -- it only outputs filename and doesn't concatenate; sorry not sorry
cat F.             % read from stdin into variable F
cat(filename,M).   % read filename into variable M (as a list of codes).
println(S,codes).  % print codes to stream S
println(codes).    % print codes to stdout
puts(S,msg).       % put msg to stream S (in internal encoding)
puts(msg).         % put msg to stdout (in internal encoding)
make.              % run `make`
make install.      % run `doas make install` (to use a program other than doas set SUDO)
make target.       % run `make target`
log.               % git -P log --oneline
add filename.      % git add filename
status.            % git status -s
commit             % git commit
diff.              % git -P diff
diff whatever.     % git -P diff whatever
file somefile.     % run `file somefile`
clear.             % clear screen

rot(P,X,Y,Z).       % call(P,Z,X,Y). n.b. this is backwards w.r.t. forth
swap(P,X,Y).        % call(P,Y,X).
dup(P,X,X).         % call(P,X).
drop(P,X).          % call(P,X,_).
zip(Xs,Ys,Zs).      % Zs is a list of `X-Y' pairs for X in Xs and Y in Ys
zipWith(P,Xs,Ys,Zs) % Zs = [ Z | call(P,X,Y,Z), X <- Xs, Y <- Yz ].
takeWhile(P,Xs,Ys)  % take elements from Xs until P fails

group(X,G). % indices of elements of X partitioned according to X/= and sorted according to the term ordering on X
groupby(ListX,ListY,R). % partition X according to Y/=
groupby(Pred,X,R).      % call(Pred,X,X0), and group X according to X0/=
order(X,R). % R is a (origin 1) permutation vector which will sort the list X if applied to it
R <- A@B    % R is A indexed by (origin 1) list of indices B


Additional operators are defined for convenience:
        p &= q             % defined as `p <> filter(q).'
        p <> q each        % each modifies q(X,Y) to act instead as maplist(q,X,Y)
        p <> q with l each % if l is a list of items l0,..,ln, `with' generates a list of closures
                           % Q = q(l0),..,q(ln) which `each' modifies to act as maplist(call,Q,X,Y).
        p && q             % &&/3 calls both p and q on the third argument, &&/2 just calls p and q.

Examples:
--
log <> length.                              % how many git commits have been made?
fl (file).                                  % output the code in file.pl via portray_clause
fl +(fl)/2 <> length.                       % how many clauses does fl/2 have as defined?
find(startswith('3')) &= endswith('.pdf').  % find files starting with 3 and ending with '.pdf'
find(startswith('3') && endswith('.pdf')).  % another way of expressing the same

% read a list of files starting with '3' and ending with '.pdf' into a variable, edit its contents with editor,
% and then assign the edited result to the global variable test (read back in as a list via read/2).
test <- ied <-- find(startswith('3')) &= startswith('.pdf').

% output list of filenames that would be captured by the regex `(.*).pdf$'
find(drop(rot(atom_concat,'.pdf'))) <> maplist(rot(atom_concat,'.pdf')).

% count number of commits since last push
X <- cmd([git,'show-ref','origin/master']) <> nth(1) <> limit(7), log <> takeWhile(\+ prefix(X)) <> length.

%%%%
% example session demonstrating the use of some of the operators;
% lines starting with `$' represent user input:
%%%%
$ test <- =([a,b,c,d,e]).   % repeat each element n times where n is the 1-origin index of the element
$ I <- (rot(fd_domain,1) <-- $test <> length) <> fd_dom, $test <> swap(repeat) with I each.
[a]
[b,b]
[c,c,c]
[d,d,d,d]
[e,e,e,e,e]
$ t <- =([[a,b,c],[d,e],[f,g,h],[d,e],[i,j,k,l],[m,n],[o]]).  % sort list of lists by frequency of list lengths
$ (sortby(length) <-- $t <> groupby(length)) <> fold(append). % n.b. groupby/sortby are not stable
[o]
[i,j,k,l]
[a,b,c]
[f,g,h]
[d,e]
[d,e]
[m,n]

--
The lists by length frequency problem is taken from 'Ninety-Nine Prolog Problems', see:
    https://www.ic.unicamp.br/~meidanis/courses/mc336/2009s2/prolog/problemas/
