psh is a toy shell/personal experiment. I haven't quite found the correct
principles in terms of which it should be constructed, so all the code that
is present currently might get thrown right out; there is also quite a bit
of missing functionality - job control isn't implemented, crtl-C causes psh
to exit, etc.

psh can be built by running `make` (with any posix make). gplc, the gprolog
compiler, is the only build dependency. Some psh commands assume other runtime
dependencies, (e.g., less/1 assumes less is installed).

psh uses op/3 to define operators for its syntax (and uses call/1 on inputs).
Unlike the prolog top_level, psh does not show variable bindings or prompt for alternate solutions.

psh pipes have the following syntax (note these are predicate compositions not pipes
between external processes):
	p <> q <> r.   %% equivilent to p(X), q(X,Y), r(Y,Z), puts(Z) (with printing
                       %% automatically lifted over lists)

        X <- p.        %% call(p,X).
	var <- p.      %% call(p,X), g_assign(var,X). (i.e, assign global variable)

	X <-- p.       %% call(p,X).
	X <-- p <> q.  %% call(p,Y), call(q,Y,X).
	r <-- p <> q.  %% call(p,Y), call(q,Y,X), call(r,X).

Note that one of the limitations of the current syntax is that routines
which require variables to be instatiated early may throw errors,
a routine used such as r in (r <-- p <> q) will however have its dependencies
appropriately ordered; for example, if r and s are routines which require
instatiated variables, and p and q which do not, then the following will avoid
exceptions:
	s <-- r <-- p <> q.

The precedence for these operators is set to be lower than comma so that
they can be used such as in (X <- p, Y <- q(X)).

Additionally a syntax somewhat similar to posix shell variables is supported:
	$var       %% g_read(var,X),puts(X). (i.e, print global variable)
	$var <> p. %% g_read(var,X),call(p,X).

Currently substition semantics for e.g., global variables are not supported.

psh attempts (probably poorly) to define predicates so that if p/n for some
n outputs to the terminal, then p/(n+1) 'outputs' to the last variable.

Many routines, such as cd/pwd/ed/file are set as unary operators and need to
be surrounded in parenthesis for them to be used as atoms. Notable routines include:

ed filename.       % edit filename in EDITOR (default: vi)
ied(data,O)        % edit data as list of prolog clauses in EDITOR then read/2 into O.
fl.                % list files ending in .pl
fl +f/n.           % display code from the source file for functor f with arity n
fl filename.       % show the source of filename.pl using portray_clause
edit filename.     % edit filename.pl in EDITOR
edit +f/n.         % edit the source file for functor f with arity n in EDITOR
	           %    ( for editors other than vi, add config(editor_line_flag,FLAG) to pshrc to support jumping to the
                   %      the line number a predicate is defined on).
cd dir.            % change directory to dir
pwd.               % working directory
ls.                % list files not starting with '.'
lsd.               % list directories
less(list).        % display list of codes in `less`
find(p).           % find files 1 level deep satisfying predicate p/1
find(p,depth).     % find files upto depth satisfying predicate p/1
find(p,depth,dir). % find files upto depth satisfying predicate p/1 in dir
filter(p,dom,sat). % sat is a list containing solutions of p constrained to domain dom
                   %  bug : some predicates can fail early and only return the first match. I should look into this.
endswith(str,x).   % x ends with str
startswith(str,x). % x starts with str
limit(list).       % output first 10 items in list
limit(c,list).     % output first c items in list (or last c items if negative).
pred via filename. % display the source for predicate pred as defined in filename
where p/n.         % display the path to the file that defines predicate p with arity n
cat filename.      % this is badly named -- it only outputs filename and doesn't concatentate; sorry not sorry
cat F.             % read from stdin into variable F
cat(filename,M).   % read filename into variable M (as a list of codes).
println(S,codes).  % print codes to stream S
println(codes).    % print codes to stdout
puts(S,msg).       % put msg to stream S (in internal encoding)
puts(msg).         % put msg to stdout (in internal encoding)
make.              % run `make`
make install.      % run `doas make install` (I should probably have this check for SUDO= or something)
make target.       % run `make target`
log.               % git -P log --oneline
add filename.      % git add filename
status.            % git status -s
commit             % git commit
diff.              % git -P diff
diff whatever.     % git -P diff whatever
file somefile.     % run `file somefile`
clear.             % you have three guesses

rot(P,X,Y,Z).       % call(P,Z,X,Y). n.b. this is backwards w.r.t. forth
swap(P,X,Y).        % call(P,Y,X).
dup(P,X,X).         % call(P,X).
drop(P,X).          % call(P,X,_).
zip(Xs,Ys,Zs).      % Zs is a list of `X-Y' pairs for X in Xs and Y in Ys
zipWith(P,Xs,Ys,Zs) % Zs = [ Z | call(P,X,Y,Z), X <- Xs, Y <- Yz ].
takeWhile(P,Xs,Ys)  % take elements from Xs until P fails

group(X,G). % indices of elements of X partitioned according to X/= and sorted according to the term ordering on X
groupby(ListX,ListY,R). % partition X according to Y/=
groupby(Pred,X,R).      % call(Pred,X,X0), and group X according to X0/=
order(X,R). % R is a (origin 1) permutation vector which will sort the list X if applied to it
R <- A@B    % R is A indexed by (origin 1) list of indices B

Additional operators are defined for convenience:
	p &= q             % defined as `p <> filter(q).'
	p <> q each        % each modifies q(X,Y) to act instead as maplist(q,X,Y)
	p <> q with l each % if l is a list of items l0,..,ln, `with' generates a list of closures
                           % Q = q(l0),..,q(ln) which `each' modifies to act as maplist(call,Q,X,Y).
	p && q             % &&/3 calls both p and q on the third argument, &&/2 just calls p and q.

Psh will also 'resolve' predicates to atoms in some cases. This faculty supports inputing path expressions
with fewer quotes, but also permits more general expressions as inputs predicates which support it.  The following
conventions are used:
	A predicate, atom_resolve(X,Y) is defined which will unify X with Y iff X is an atom, or call(X,Y) otherwise.

	Operators such as (//), (~/), (/), (dot), (++) are defined to build up path expressions. These use atom_resolve
	so that they can be nested. An expression such as:
		//home/me/file dot pdf
	will reduce to the atom '/home/me/file.pdf'.

	Some psh 'routines', such as cd, ls, etc. also use atom_resolve so that path expressions can be reduced. Thus:
		cd ~/src/psh.
	will work as expected.

Examples:
--
log <> length.                              % how many git commits have been made?
fl (file).                                  % output the code in file.pl via portray_clause
fl +(fl)/2 <> length.                       % how many clauses does fl/2 have as defined?
find(startswith('3')) &= endswith('.pdf').  % find files starting with 3 and ending with '.pdf'
find(startswith('3') && endswith('.pdf')).  % another way of expressing the same

% read a list of files starting with '3' and ending with '.pdf' into a variable, edit its contents with editor,
% and then assign the edited result to the global variable test (read back in as a list via read/2).
test <- ied <-- find(startswith('3')) &= startswith('.pdf').

% output list of filenames that would be captured by the regex `(.*).pdf$'
find(drop(rot(atom_concat,'.pdf'))) <> maplist(rot(atom_concat,'.pdf')).

% count number of commits since last push
X <- cmd([git,'show-ref','origin/master']) <> nth(1) <> limit(7), log <> takeWhile(\+ prefix(X)) <> length.

%%%%
% example session demonstrating the use of some of the operators;
% lines starting with `$' represent user input:
%%%%
$ test <- =([a,b,c,d,e]).   % repeat each element n times where n is the 1-origin index of the element
$ I <- (rot(fd_domain,1) <-- $test <> length) <> fd_dom, $test <> swap(repeat) with I each.
[a]
[b,b]
[c,c,c]
[d,d,d,d]
[e,e,e,e,e]
$ t <- =([[a,b,c],[d,e],[f,g,h],[d,e],[i,j,k,l],[m,n],[o]]).  % sort list of lists by frequency of list lengths
$ (sortby(length) <-- $t <> groupby(length)) <> fold(append). % n.b. groupby/sortby are not stable
[o]
[i,j,k,l]
[a,b,c]
[f,g,h]
[d,e]
[d,e]
[m,n]

--
The lists by length frequency problem is taken from 'Ninety-Nine Prolog Problems', see:
    https://www.ic.unicamp.br/~meidanis/courses/mc336/2009s2/prolog/problemas/
